---
title: Querying
description: How to create, read, update, and delete records using SQL template literals
icon: Search
---

Zodgres provides a simple and intuitive API for querying collections using Postgres.js ES6 Tagged Template Strings.

## create()

Create single or multiple records in a collection.

### Creating a Single Record

```typescript
const users = await db.collection('users', {
  id: z.number().optional(),
  name: z.string(),
  age: z.number().optional(),
});

const user = await users.create({
  name: 'John Doe',
  age: 30,
});

// Result: { id: 1, name: 'John Doe', age: 30 }
```

### Creating Multiple Records

```typescript
const newUsers = await users.create([
  { name: 'Alice' },
  { name: 'Bob', age: 25 },
  { name: 'Carol', age: 35 },
]);

// Result: Array of created user objects with generated IDs
```

### Validation

All data is validated against your Zod schema:

```typescript
// ❌ This will throw a validation error
await users.create({
  name: '', // Empty string validation may fail depending on schema
  age: -5, // Negative age if min(0) constraint exists
});
```

## select()

Retrieve records from a collection using SQL template literals.

### Select All Records

```typescript
// Select all users (both forms work)
const allUsers = await users.select();
const allUsers = await users.select`*`;
```

### Select with Conditions

```typescript
// Select with WHERE clause
const specificUser = await users.select`* WHERE name = ${'John Doe'}`;

// Select with multiple conditions
const adults = await users.select`* WHERE age >= ${18}`;
```

### Select Specific Columns

```typescript
// Select only specific columns
const names = await users.select`name`;
const nameAndAge = await users.select`name, age`;

// Select columns with conditions
const adultNames = await users.select`name WHERE age > ${25}`;
```

### Ordering and Limiting

```typescript
// Order results
const orderedUsers = await users.select`* ORDER BY age DESC`;

// Limit results
const limitedUsers = await users.select`* LIMIT ${10}`;

// Combined ordering and limiting
const topUsers = await users.select`* ORDER BY id LIMIT ${5}`;
```

### Aggregations

```typescript
// Count records - note: returns string, not number
const countResult = await users.select<{ count: string }>`COUNT(*)`;

// Other aggregations work similarly
const stats = await users.select`AVG(age) as average_age WHERE age IS NOT NULL`;
```

## selectOne()

Select a single record. Automatically adds `LIMIT 1` and returns the first result or `undefined`.

```typescript
// Get first user
const firstUser = await users.selectOne`*`;

// Get specific user
const specificUser = await users.selectOne`* WHERE name = ${'John'}`;

// ❌ This will throw an error - LIMIT not allowed
// await users.selectOne`* LIMIT 1`;
```

## update()

Update records and return the updated data.

### Basic Updates

```typescript
// Update specific record
const updated = await users.update`name = ${'Updated Name'} WHERE id = ${1}`;
// Returns: [{ id: 1, name: 'Updated Name', age: 30 }]

// Update multiple records
const multiUpdated = await users.update`age = ${25} WHERE name = ${'Bob'}`;
```

### Update Multiple Fields

```typescript
// Update multiple fields at once
const updated = await users.update`
  name = ${'New Name'}, age = ${31}
  WHERE id = ${2}
`;
```

### Update All Records

```typescript
// Update all records (no WHERE clause)
const allUpdated = await users.update`status = ${'active'}`;
```

### Update with Complex Conditions

```typescript
// Update with IN clause
const updated = await users.update`
  status = ${'inactive'}
  WHERE id IN (${1}, ${3}, ${5})
`;
```

## delete()

Delete records from a collection.

### Delete All Records

```typescript
// Delete all records, returns count
const deletedCount = await users.delete();
// Returns: number (e.g., 5)
```

### Delete with Conditions

```typescript
// Delete specific records, returns count
const deletedCount = await users.delete`WHERE age < ${18}`;
// Returns: number of deleted records
```

### Delete with RETURNING

```typescript
// Delete and return the deleted records
const deletedUsers = await users.delete<{ id: number, name: string }>`
  WHERE name = ${'John'} RETURNING *
`;
// Returns: Array of deleted user objects
```

## count()

Count records in a collection.

```typescript
// Count all records
const totalUsers = await users.count();

// Count with conditions
const adultCount = await users.count`WHERE age >= ${18}`;

// Count with complex conditions
const activeAdultCount = await users.count`
  WHERE age >= ${18} AND status = ${'active'}
`;
```

## insert()

Insert records using raw SQL and return the inserted data.

```typescript
// Insert single record
const inserted = await users.insert`(name, age) VALUES (${'John'}, ${30})`;
// Returns: [{ id: 1, name: 'John', age: 30 }]

// Insert with only some fields
const inserted = await users.insert`(name) VALUES (${'Jane'})`;
// Returns: [{ id: 2, name: 'Jane', age: null }]

// Insert multiple records in one query
const inserted = await users.insert`
  (name, age) VALUES
  (${'Alice'}, ${25}),
  (${'Bob'}, ${30}),
  (${'Charlie'}, ${35})
`;
// Returns: Array of inserted user objects
```

<Callout type="info">
The `insert()` method uses raw SQL, unlike `create()` which accepts objects. For simple object-based inserts, use `create()`. For complex SQL operations, use `insert()`.
</Callout>

## Parameter Safety

Template literals automatically handle parameter escaping:

```typescript
const searchTerm = "'; DROP TABLE users; --";

// ✅ Safe - parameters are properly escaped
const results = await users.select`* WHERE name = ${searchTerm}`;

// ❌ Never do this - vulnerable to SQL injection
// const results = await users.select`* WHERE name = '${searchTerm}'`;
```

## Error Handling

Handle query errors gracefully:

```typescript
try {
  const user = await users.create({
    name: 'John',
    age: 30,
  });
} catch (error) {
  if (error.code === '23505') {
    // Unique constraint violation
    console.error('Duplicate key violation');
  } else if (error instanceof z.ZodError) {
    // Validation error
    console.error('Invalid data:', error.errors);
  } else {
    console.error('Database error:', error.message);
  }
}
```

## Type Safety

All query results are properly typed based on your schema:

```typescript
const users = await db.collection('users', {
  id: z.number().optional(),
  name: z.string(),
  age: z.number().optional(),
});

const allUsers = await users.select();
// Type: Array<{ id: number, name: string, age: number | undefined }>

allUsers.forEach(user => {
  console.log(user.name); // ✅ TypeScript knows this is a string
  console.log(user.age);  // ✅ TypeScript knows this can be undefined
  // console.log(user.email); // ❌ TypeScript error - not in schema
});
```

## Performance Tips

### Batch Operations

Use batch operations for better performance:

```typescript
// ✅ Better - single query for multiple records
const newUsers = await users.create([
  { name: 'User 1' },
  { name: 'User 2' },
  { name: 'User 3' },
]);

// ❌ Slower - multiple queries
for (const userData of userDataArray) {
  await users.create(userData);
}
```

### Select Only Needed Columns

Reduce data transfer by selecting only required columns:

```typescript
// ✅ Better - only select needed columns
const userNames = await users.select`name WHERE age > ${18}`;

// ❌ Slower - transfers unnecessary data
const activeUsers = await users.select`* WHERE age > ${18}`;
const names = activeUsers.map(u => u.name);
```